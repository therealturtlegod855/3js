<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Voxel Terrain FPS</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.5);
      cursor: pointer;
      z-index: 10;
    }
  </style>

  <!-- PointerLock + imports rely on importmap -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.164.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="overlay">Click to play</div>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

// ---------- Perlin noise ----------
class Perlin {
  constructor() {
    this.permutation = [];
    for (let i = 0; i < 256; i++) this.permutation[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
    }
    this.p = new Array(512);
    for (let i = 0; i < 512; i++) this.p[i] = this.permutation[i & 255];
  }
  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  lerp(t, a, b) { return a + t * (b - a); }
  grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }
  noise(x, y = 0, z = 0) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;
    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
    const u = this.fade(x), v = this.fade(y), w = this.fade(z);
    const A = this.p[X] + Y;
    const AA = this.p[A] + Z;
    const AB = this.p[A + 1] + Z;
    const B = this.p[X + 1] + Y;
    const BA = this.p[B] + Z;
    const BB = this.p[B + 1] + Z;

    return this.lerp(w,
      this.lerp(v,
        this.lerp(u, this.grad(this.p[AA], x, y, z),
                     this.grad(this.p[BA], x - 1, y, z)),
        this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                     this.grad(this.p[BB], x - 1, y - 1, z))
      ),
      this.lerp(v,
        this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                     this.grad(this.p[BA + 1], x - 1, y, z - 1)),
        this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                     this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))
      )
    );
  }
}

const perlin = new Perlin();

// ---------- Three.js setup ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(50, 100, 50);
scene.add(dirLight);

// ---------- Voxel terrain ----------
const worldWidth = 64;
const worldDepth = 64;
const maxHeight  = 16;
const voxelSize  = 1;

const noiseScale = 0.08;
const heightMultiplier = maxHeight * 0.7;

// store solid voxels in a Set for collision queries
const solidVoxels = new Set();
function voxelKey(x, y, z) { return `${x},${y},${z}`; }

const cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
const cubeMat = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
const maxInstances = worldWidth * worldDepth * maxHeight;
const instancedMesh = new THREE.InstancedMesh(cubeGeo, cubeMat, maxInstances);
instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(instancedMesh);

let instanceIndex = 0;
const dummy = new THREE.Object3D();

for (let x = 0; x < worldWidth; x++) {
  for (let z = 0; z < worldDepth; z++) {
    const nx = x * noiseScale;
    const nz = z * noiseScale;
    const n = perlin.noise(nx, nz);
    const height = Math.floor((n * 0.5 + 0.5) * heightMultiplier);

    for (let y = 0; y < height; y++) {
      const wx = x - worldWidth / 2;
      const wy = y;
      const wz = z - worldDepth / 2;

      dummy.position.set(
        wx * voxelSize,
        wy * voxelSize,
        wz * voxelSize
      );
      dummy.updateMatrix();
      instancedMesh.setMatrixAt(instanceIndex++, dummy.matrix);
      solidVoxels.add(voxelKey(wx, wy, wz));
    }
  }
}

instancedMesh.count = instanceIndex;
instancedMesh.instanceMatrix.needsUpdate = true;

// Ground plane (visual only)
const groundGeo = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x334433 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -1;
scene.add(ground);

// ---------- Player, controls, physics ----------
const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());

// basic player state
const playerPos = controls.getObject().position;
playerPos.set(0, 10, 0);
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let canJump = false;

const move = { forward: false, backward: false, left: false, right: false };
const speed = 10;       // walking speed
const jumpSpeed = 5;    // jump impulse
const gravity = 20;     // gravity strength
const playerRadius = 0.3;
const playerHeight = 1.7;

// pointer lock UI
const overlay = document.getElementById('overlay');
overlay.addEventListener('click', () => {
  controls.lock();
});
controls.addEventListener('lock', () => {
  overlay.style.display = 'none';
});
controls.addEventListener('unlock', () => {
  overlay.style.display = 'flex';
});

// keyboard input
document.addEventListener('keydown', (e) => {
  switch (e.code) {
    case 'KeyW': move.forward = true; break;
    case 'KeyS': move.backward = true; break;
    case 'KeyA': move.left = true; break;
    case 'KeyD': move.right = true; break;
    case 'Space':
      if (canJump) {
        velocity.y = jumpSpeed;
        canJump = false;
      }
      break;
  }
});
document.addEventListener('keyup', (e) => {
  switch (e.code) {
    case 'KeyW': move.forward = false; break;
    case 'KeyS': move.backward = false; break;
    case 'KeyA': move.left = false; break;
    case 'KeyD': move.right = false; break;
  }
});

// helper: check if a voxel at integer coords is solid
function isSolidVoxel(ix, iy, iz) {
  return solidVoxels.has(voxelKey(ix, iy, iz));
}

// very simple collision: treat player as a vertical capsule but approximate as 3 sampled points
function resolveCollisions(pos) {
  // sample 3 points along player height: feet, middle, head
  const samples = [0.0, playerHeight * 0.5, playerHeight * 0.9];

  for (let axis of ['x', 'y', 'z']) {
    const original = pos[axis];
    let overlap = 0;

    for (let s of samples) {
      const px = pos.x;
      const py = pos.y + s;
      const pz = pos.z;

      const vx = Math.floor(px + (axis === 'x' && pos[axis] < original ? -playerRadius : (axis === 'x' ? playerRadius : 0)));
      const vy = Math.floor(py + (axis === 'y' && pos[axis] < original ? -playerRadius : (axis === 'y' ? playerRadius : 0)));
      const vz = Math.floor(pz + (axis === 'z' && pos[axis] < original ? -playerRadius : (axis === 'z' ? playerRadius : 0)));

      if (isSolidVoxel(vx, vy, vz)) {
        // push out along that axis
        const sign = pos[axis] > original ? 1 : -1;
        const voxelBoundary = sign > 0 ? vx - playerRadius : vx + 1 + playerRadius;
        overlap = Math.max(overlap, sign > 0 ? voxelBoundary - pos[axis] : pos[axis] - voxelBoundary);
      }
    }

    if (overlap > 0) {
      const sign = pos[axis] > original ? -1 : 1;
      pos[axis] += sign * overlap;
      if (axis === 'y' && sign === 1 && velocity.y < 0) {
        // collided with ground
        velocity.y = 0;
        canJump = true;
      }
    }
  }
}

// ---------- Animation loop ----------
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();
  if (controls.isLocked === true) {
    // movement input -> direction
    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    // horizontal velocity
    if (direction.lengthSq() > 0) {
      const moveX = direction.x * speed * delta;
      const moveZ = direction.z * speed * delta;

      // move in camera space (forward/right)
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

      velocity.x = forward.x * direction.z * speed + right.x * direction.x * speed;
      velocity.z = forward.z * direction.z * speed + right.z * direction.x * speed;
    } else {
      velocity.x = 0;
      velocity.z = 0;
    }

    // gravity
    velocity.y -= gravity * delta;
    if (velocity.y < -50) velocity.y = -50;

    // integrate position
    playerPos.x += velocity.x * delta;
    playerPos.y += velocity.y * delta;
    playerPos.z += velocity.z * delta;

    // collisions
    resolveCollisions(playerPos);
  }

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
